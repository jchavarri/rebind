Basic functions

  $ cat > input.js <<\EOF
  > const nano = Nano("test", 4);
  > EOF

  $ rebind input.js | tee output.ml
  type nano
  
  external nano : string -> float -> nano = "Nano"
  
  let nano = nano "test" 4
  

  $ melc -ppx melppx output.ml
  File "output.ml", line 5, characters 23-24:
  5 | let nano = nano "test" 4
                             ^
  Error: This expression has type int but an expression was expected of type
           float
    Hint: Did you mean `4.'?
  [2]

Require statements, more than one statement

  $ cat > input.js <<\EOF
  > const nano = require('nano')(5, "fsdf", 43);
  > const blue = require('blue')("gf");
  > EOF

  $ rebind input.js | tee output.ml
  type nano
  type blue
  
  external nano : float -> string -> float -> nano = "nano" [@@mel.module]
  external blue : string -> blue = "blue" [@@mel.module]
  
  let blue = (require "blue") "gf"
  let nano = (require "nano") 5 "fsdf" 43
  

  $ melc -ppx melppx output.ml
  File "output.ml", line 7, characters 12-19:
  7 | let blue = (require "blue") "gf"
                  ^^^^^^^
  Error: Unbound value require
  [2]

Track identifiers across statements

  $ cat > input.js <<\EOF
  > const nano = require('nano');
  > const test = nano(5, "fsdf", 43);
  > EOF

  $ rebind input.js | tee output.ml
  type nano
  
  external nano : float -> string -> float -> nano = "nano" [@@mel.module]
  
  let test = nano 5 "fsdf" 43
  

  $ melc -ppx melppx output.ml
  File "output.ml", line 5, characters 16-17:
  5 | let test = nano 5 "fsdf" 43
                      ^
  Error: This expression has type int but an expression was expected of type
           float
    Hint: Did you mean `5.'?
  [2]

Single require

  $ cat > input.js <<\EOF
  > const blue = require('blue');
  > EOF

  $ rebind input.js | tee output.ml
  type blue
  

  $ melc -ppx melppx output.ml
  // Generated by Melange
  /* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */

Basic object property access

  $ cat > input.js <<\EOF
  > const nano = require('nano')('http://localhost:5984');
  > nano.db.test(23);
  > const blue = require('blue');
  > const go = blue.pill.jump(23);
  > EOF

  $ rebind input.js | tee output.ml
  type nano
  type db
  type test
  type blue
  type pill
  type jump
  
  external nano : string -> nano = "nano" [@@mel.module]
  external db : nano -> db = "db" [@@mel.get]
  external test : db -> float -> test = "test" [@@mel.send]
  external blue : blue = "blue" [@@mel.module]
  external pill : blue -> pill = "pill" [@@mel.get]
  external jump : pill -> float -> jump = "jump" [@@mel.send]
  
  let go = blue##pill##jump 23;;
  
  nano##db##test 23
  
  let nano = (require "nano") "http://localhost:5984"
  

  $ melc -ppx melppx output.ml
  File "output.ml", line 15, characters 9-19:
  15 | let go = blue##pill##jump 23;;
                ^^^^^^^^^^
  Error: This expression is not an object; it has type blue
  [2]

Functions as callbacks

  $ cat > input.js <<\EOF
  > const nano = require('nano')('http://localhost:5984');
  > nano.db.create('foo', (err, body, headers) => { // ... stuff here
  > })
  > EOF

  $ rebind input.js | tee output.ml
  type nano
  type err
  type body
  type headers
  type callback
  type db
  type create
  
  external nano : string -> nano = "nano" [@@mel.module]
  external db : nano -> db = "db" [@@mel.get]
  
  external create : db -> string -> (err -> body -> headers -> callback) -> create
    = "create"
  [@@mel.send]
  ;;
  
  nano##db##create "foo" (fun err body headers -> ())
  
  let nano = (require "nano") "http://localhost:5984"
  

  $ melc -ppx melppx output.ml
  File "output.ml", line 17, characters 0-8:
  17 | nano##db##create "foo" (fun err body headers -> ())
       ^^^^^^^^
  Error: This expression is not an object; it has type string -> nano
  [2]

Object constants

  $ cat > input.js <<\EOF
  > var Airtable = require('airtable');
  > Airtable.configure({
  >     endpointUrl: 'https://api.airtable.com',
  >     apiKey: 'YOUR_API_KEY'
  > });
  > EOF

  $ rebind input.js | tee output.ml
  type airtable2
  type configureParam
  type configure
  
  external makeConfigureParam :
    apiKey:string -> endpointUrl:string -> unit -> configureParam = ""
  [@@mel.obj]
  
  external airtable2 : airtable2 = "airtable" [@@mel.module]
  
  external configure : airtable2 -> configureParam -> configure = "configure"
  [@@mel.send]
  ;;
  
  airtable##configure
    [%mel.obj
      { endpointUrl = "https://api.airtable.com"; apiKey = "YOUR_API_KEY" }]
  
  $ melc -ppx melppx output.ml
  File "output.ml", line 15, characters 0-8:
  15 | airtable##configure
       ^^^^^^^^
  Error: Unbound value airtable
  Hint: Did you mean airtable2?
  [2]

Objects, properties, callbacks, modules

  $ cat > input.js <<\EOF
  > var Airtable = require('airtable');
  > Airtable.configure({
  >     endpointUrl: 'https://api.airtable.com',
  >     apiKey: 'YOUR_API_KEY'
  > });
  > var base = Airtable.base('appXXXXXXXX');
  > base('MyBase').select({
  >   // Selecting the first 3 records in Grid view:
  >   maxRecords: 3,
  >   view: "Grid view"
  > }).eachPage(function page(records, fetchNextPage) {
  >   // This function (`page`) will get called for each page of records.
  > 
  >   records.forEach(function(record) {
  >       console.log('Retrieved', record.get('Task'));
  >   });
  > 
  >   // To fetch the next page of records, call `fetchNextPage`.
  >   // If there are more records, `page` will get called again.
  >   // If there are no more records, `done` will get called.
  >   fetchNextPage();
  > 
  > }, function done(err) {
  >   if (err) { console.error(err); return; }
  > });
  > EOF

  $ rebind input.js | tee output.ml
  type airtable2
  type configureParam
  type configure
  type base
  type records
  type fetchNextPage
  type page
  type err
  type done_
  type selectParam
  type select
  type eachPage
  
  external makeConfigureParam :
    apiKey:string -> endpointUrl:string -> unit -> configureParam = ""
  [@@mel.obj]
  
  external airtable2 : airtable2 = "airtable" [@@mel.module]
  
  external configure : airtable2 -> configureParam -> configure = "configure"
  [@@mel.send]
  
  external base : airtable2 -> string -> base = "base" [@@mel.send]
  
  external makeSelectParam :
    view:string -> maxRecords:float -> unit -> selectParam = ""
  [@@mel.obj]
  
  external select : base -> selectParam -> select = "select" [@@mel.send]
  
  external eachPage :
    select -> (records -> fetchNextPage -> page) -> (err -> done_) -> eachPage
    = "eachPage"
  [@@mel.send]
  ;;
  
  ((base "MyBase")##select [%mel.obj { maxRecords = 3; view = "Grid view" }])##eachPage
    (fun records fetchNextPage ->
      records##forEach (fun record ->
          console##log "Retrieved" (record##get "Task"));
      fetchNextPage ())
    (fun err ->
      if err then (
        console##error err;
        ()))
  
  let base = airtable##base "appXXXXXXXX";;
  
  airtable##configure
    [%mel.obj
      { endpointUrl = "https://api.airtable.com"; apiKey = "YOUR_API_KEY" }]
  

  $ melc -ppx melppx output.ml
  File "output.ml", line 37, characters 7-15:
  37 | ((base "MyBase")##select [%mel.obj { maxRecords = 3; view = "Grid view" }])##eachPage
              ^^^^^^^^
  Error: This expression has type string but an expression was expected of type
           airtable2
  [2]

Identifiers with same name

  $ cat > input.js <<\EOF
  > let jPush = JPush.jPush;
  > jPush.initPush();
  > EOF

  $ rebind input.js | tee output.ml
  type jPush
  type jPush2
  type initPush
  
  external jPush : jPush = "JPush"
  external jPush2 : jPush -> jPush2 = "jPush" [@@mel.get]
  external initPush : jPush2 -> initPush = "initPush" [@@mel.send];;
  
  jPush##initPush ()
  
  let jPush = jPush##jPush
  

  $ melc -ppx melppx output.ml
  File "output.ml", line 9, characters 0-15:
  9 | jPush##initPush ()
      ^^^^^^^^^^^^^^^
  Error: This expression is not an object; it has type jPush
  [2]

Stripe example

  $ cat > input.js <<\EOF
  > var stripe = require('stripe')('sk_test_...');
  > 
  > stripe.customers.create(
  >   { email: 'customer@example.com' },
  >   function(err, customer) {
  >     err; // null if no error occurred
  >     customer; // the created customer object
  >   }
  > );
  > EOF

  $ rebind input.js | tee output.ml
  type stripe
  type createParam
  type err
  type customer
  type callback
  type customers
  type create
  
  external stripe : string -> stripe = "stripe" [@@mel.module]
  external makeCreateParam : email:string -> unit -> createParam = "" [@@mel.obj]
  external customers : stripe -> customers = "customers" [@@mel.get]
  
  external create :
    customers -> createParam -> (err -> customer -> callback) -> create = "create"
  [@@mel.send]
  ;;
  
  stripe##customers##create [%mel.obj { email = "customer@example.com" }]
    (fun err customer ->
      err;
      customer)
  
  let stripe = (require "stripe") "sk_test_..."
  

  $ melc -ppx melppx output.ml
  File "output.ml", line 18, characters 0-17:
  18 | stripe##customers##create [%mel.obj { email = "customer@example.com" }]
       ^^^^^^^^^^^^^^^^^
  Error: This expression is not an object; it has type string -> stripe
  [2]

Case with `new`

  $ cat > input.js <<\EOF
  > // From https://github.com/jchavarri/rebind/issues/3
  > const client = new AWSAppSyncClient({
  >   url: graphqlEndpoint,
  >   region: region,
  >   auth: {
  >     type: authenticationType,
  >     apiKey: apiKey
  >   }
  > });
  > EOF

  $ rebind input.js | tee output.ml
  type graphqlEndpoint
  type region
  type authenticationType
  type apiKey
  type auth
  type aWSAppSyncClientParam
  type aWSAppSyncClient
  
  external makeAuth : apiKey:apiKey -> _type:authenticationType -> unit -> auth
    = ""
  [@@mel.obj]
  
  external makeAWSAppSyncClientParam :
    auth:auth ->
    region:region ->
    url:graphqlEndpoint ->
    unit ->
    aWSAppSyncClientParam = ""
  [@@mel.obj]
  
  external aWSAppSyncClient : aWSAppSyncClientParam -> aWSAppSyncClient
    = "AWSAppSyncClient"
  [@@mel.new]
  
  let client = expressionPlaceholder
  

  $ melc -ppx melppx output.ml
  File "output.ml", line 25, characters 13-34:
  25 | let client = expressionPlaceholder
                    ^^^^^^^^^^^^^^^^^^^^^
  Error: Unbound value expressionPlaceholder
  [2]

`new` from a module

  $ cat > input.js <<\EOF
  > const Blue = require('SomethingBlue');
  > const instance = new Blue("config");
  > EOF

  $ rebind input.js | tee output.ml
  type somethingBlue
  
  external somethingBlue : string -> somethingBlue = "SomethingBlue"
  [@@mel.new] [@@mel.module]
  
  let instance = expressionPlaceholder
  

  $ melc -ppx melppx output.ml
  File "output.ml", line 6, characters 15-36:
  6 | let instance = expressionPlaceholder
                     ^^^^^^^^^^^^^^^^^^^^^
  Error: Unbound value expressionPlaceholder
  [2]

Named import

  $ cat > input.js <<\EOF
  > import { Blue } from "SomethingBlue";
  > const instance = Blue("config");
  > EOF

  $ rebind input.js | tee output.ml
  type blue
  
  external blue : string -> blue = "Blue" [@@mel.module "SomethingBlue"]
  
  let instance = blue "config";;
  
  statementBail
  

  $ melc -ppx melppx output.ml
  File "output.ml", line 7, characters 0-13:
  7 | statementBail
      ^^^^^^^^^^^^^
  Error: Unbound value statementBail
  [2]

Default imports

  $ cat > input.js <<\EOF
  > // Example from https://reasonml.chat/t/how-to-improve-my-codes/663
  > import Keycloak from 'keycloak-js';
  > const keycloak = Keycloak('config/keycloak.json');
  > keycloak.init({ onLoad: 'login-required' }).success(function(authenticated) {
  >   alert(authenticated ? 'authenticated' : 'not authenticated');
  > }).error(function() {
  >   alert('failed to initialize');
  > });
  > EOF

  $ rebind input.js | tee output.ml
  type keycloak
  type callback
  type authenticated
  type initParam
  type init
  type success
  type error
  
  external keycloak : string -> keycloak = "default" [@@mel.module "keycloak-js"]
  external makeInitParam : onLoad:string -> unit -> initParam = "" [@@mel.obj]
  external init : keycloak -> initParam -> init = "init" [@@mel.send]
  
  external success : init -> (authenticated -> callback) -> success = "success"
  [@@mel.send]
  
  external error : success -> callback -> error = "error" [@@mel.send];;
  
  ((keycloak##init [%mel.obj { onLoad = "login-required" }])##success
     (fun authenticated ->
       alert
         (match authenticated with
         | true -> "authenticated"
         | false -> "not authenticated")))##error (fun () ->
      alert "failed to initialize")
  
  let keycloak = keycloak "config/keycloak.json";;
  
  statementBail
  

  $ melc -ppx melppx output.ml
  File "output.ml", line 18, characters 2-16:
  18 | ((keycloak##init [%mel.obj { onLoad = "login-required" }])##success
         ^^^^^^^^^^^^^^
  Error: This expression is not an object; it has type string -> keycloak
  [2]

Named imports with local name

  $ cat > input.js <<\EOF
  > import { Blue as Green } from "SomethingBlue";
  > const instance = Green("config");
  > const t = green(2);
  > EOF

  $ rebind input.js | tee output.ml
  type green
  type green2
  
  external green : string -> green = "Blue" [@@mel.module "SomethingBlue"]
  external green2 : float -> green2 = "green"
  
  let t = green 2
  let instance = green "config";;
  
  statementBail
  

  $ melc -ppx melppx output.ml
  File "output.ml", line 7, characters 14-15:
  7 | let t = green 2
                    ^
  Error: This expression has type int but an expression was expected of type
           string
  [2]

Namespaced imports

  $ cat > input.js <<\EOF
  > import * as Blue from "SomethingBlue";
  > const instance = Blue("config");
  > EOF

  $ rebind input.js | tee output.ml
  type blue
  type somethingBlue
  
  external somethingBlue : string -> somethingBlue = "SomethingBlue"
  [@@mel.module]
  
  let instance = blue "config";;
  
  statementBail
  

  $ melc -ppx melppx output.ml
  File "output.ml", line 7, characters 15-19:
  7 | let instance = blue "config";;
                     ^^^^
  Error: Unbound value blue
  [2]

Unexpected token error (no need to run melc)

  $ cat > input.js <<\EOF
  > const t = Test({: 1, : 2});
  > EOF

  $ rebind input.js | tee output.ml
  Fatal error: exception Failure("Computed properties in objects are unsupported")
  Raised at Stdlib.failwith in file "stdlib.ml", line 29, characters 17-33
  Called from Shared__Handle_expression.h.(fun) in file "src/shared/handle_expression.ml", line 195, characters 21-78
  Called from Stdlib__List.fold_left in file "list.ml", line 123, characters 24-34
  Called from Shared__Handle_expression.h in file "src/shared/handle_expression.ml", line 173, characters 8-1023
  Called from Shared__Handle_expression.handle_callable_expr.(fun) in file "src/shared/handle_expression.ml", line 71, characters 40-52
  Called from Stdlib__List.fold_left in file "list.ml", line 123, characters 24-34
  Called from Shared__Handle_expression.handle_callable_expr in file "src/shared/handle_expression.ml", line 66, characters 4-399
  Called from Shared__Handle_plain_statement.h in file "src/shared/handle_plain_statement.ml", line 17, characters 12-75
  Called from Stdlib__List.fold_left in file "list.ml", line 123, characters 24-34
  Called from Shared.get_output in file "src/shared/shared.ml", line 14, characters 4-150
  Called from Dune__exe__Rebind.processContent in file "src/native/rebind.ml", line 33, characters 6-69
  Called from Dune__exe__Rebind in file "src/native/rebind.ml", line 49, characters 7-24

Using a reserved word (`then`)

  $ cat > input.js <<\EOF
  > var stripe = require("stripe");
  > stripe.createToken('bank_account').then(function(result) {});
  > EOF

  $ rebind input.js | tee output.ml
  Fatal error: exception Failure("ocamlformat error")
  Raised at Stdlib.failwith in file "stdlib.ml", line 29, characters 17-33
  Called from Dune__exe__Rebind.processContent in file "src/native/rebind.ml", line 42, characters 18-46
  Called from Dune__exe__Rebind in file "src/native/rebind.ml", line 49, characters 7-24

  $ melc -ppx melppx output.ml
  // Generated by Melange
  /* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */

Dots and other strange chars in import names

  $ cat > input.js <<\EOF
  > const BN = require('bn.js');
  > 
  > var a = new BN('dead', 16);
  > var b = new BN('101010', 2);
  > 
  > var res = a.add(b);
  > 
  > import * as stripe from 'stripe-js';
  > stripe.createToken('bank_account');
  > EOF

  $ rebind input.js | tee output.ml
  type bnjs
  type add
  type stripe
  type stripejs
  type createToken
  
  external bnjs : string -> float -> bnjs = "bn.js" [@@mel.new] [@@mel.module]
  external add : bnjs -> bnjs -> add = "add" [@@mel.send]
  external stripejs : stripejs = "stripe-js" [@@mel.module]
  
  external createToken : stripejs -> string -> createToken = "createToken"
  [@@mel.send]
  ;;
  
  stripe##createToken "bank_account";;
  statementBail
  
  let res = a##add b
  let b = expressionPlaceholder
  let a = expressionPlaceholder
  

  $ melc -ppx melppx output.ml
  File "output.ml", line 15, characters 0-6:
  15 | stripe##createToken "bank_account";;
       ^^^^^^
  Error: Unbound value stripe
  Hint: Did you mean stripejs?
  [2]

=== Examples from https://github.com/yawaramin/bucklescript-bindings-cookbook ===

--- Globals ---

Variable in global module

  $ cat > input.js <<\EOF
  > function calculateCircumference(radius) {
  >   return 2 * Math.PI * radius;
  > }
  > EOF

  $ rebind input.js | tee output.ml
  let calculateCircumference radius = 2 * math##pI * radius
  

  $ melc -ppx melppx output.ml
  File "output.ml", line 1, characters 40-44:
  1 | let calculateCircumference radius = 2 * math##pI * radius
                                              ^^^^
  Error: Unbound value math
  [2]

Function in global module

--- Modules ---

Function in commonJS/ES6 module

  $ cat > input.js <<\EOF
  > const path = require('path');
  > path.join('a', 'b')
  > EOF

  $ rebind input.js | tee output.ml
  type path
  type join
  
  external path : path = "path" [@@mel.module]
  external join : path -> string -> string -> join = "join" [@@mel.send];;
  
  path##join "a" "b"
  

  $ melc -ppx melppx output.ml
  File "output.ml", line 7, characters 0-10:
  7 | path##join "a" "b"
      ^^^^^^^^^^
  Error: This expression is not an object; it has type path
  [2]

Import entire module as a value

  $ cat > input.js <<\EOF
  > const foo = require('foo');
  > foo(1);
  > EOF

  $ rebind input.js | tee output.ml
  type foo
  
  external foo : float -> foo = "foo" [@@mel.module];;
  
  foo 1
  

  $ melc -ppx melppx output.ml
  File "output.ml", line 5, characters 4-5:
  5 | foo 1
          ^
  Error: This expression has type int but an expression was expected of type
           float
    Hint: Did you mean `1.'?
  [2]

Import ES6 module default export

  $ cat > input.js <<\EOF
  > import foo from 'foo';
  > foo(1);
  > EOF

  $ rebind input.js | tee output.ml
  type foo
  
  external foo : float -> foo = "default" [@@mel.module "foo"];;
  
  foo 1;;
  statementBail
  

  $ melc -ppx melppx output.ml
  File "output.ml", line 5, characters 4-5:
  5 | foo 1;;
          ^
  Error: This expression has type int but an expression was expected of type
           float
    Hint: Did you mean `1.'?
  [2]

Function scoped inside an object in a module

  $ cat > input.js <<\EOF
  > const foo = require('foo');
  > foo.bar.baz();
  > EOF

  $ rebind input.js | tee output.ml
  type foo
  type bar
  type baz
  
  external foo : foo = "foo" [@@mel.module]
  external bar : foo -> bar = "bar" [@@mel.get]
  external baz : bar -> baz = "baz" [@@mel.send];;
  
  foo##bar##baz ()
  

  $ melc -ppx melppx output.ml
  File "output.ml", line 9, characters 0-8:
  9 | foo##bar##baz ()
      ^^^^^^^^
  Error: This expression is not an object; it has type foo
  [2]

Function with rest args

  $ cat > input.js <<\EOF
  > const dir = path.join('a', 'b', 'c')
  > EOF

  $ rebind input.js | tee output.ml
  type path
  type join
  
  external join : path -> string -> string -> string -> join = "join" [@@mel.send]
  
  let dir = path##join "a" "b" "c"
  

  $ melc -ppx melppx output.ml
  File "output.ml", line 6, characters 10-14:
  6 | let dir = path##join "a" "b" "c"
                ^^^^
  Error: Unbound value path
  [2]

Call a function with named arguments for readability

  $ cat > input.js <<\EOF
  > const nums = range(start, stop, step)
  > EOF

  $ rebind input.js | tee output.ml
  type start
  type stop
  type step
  type range
  
  external range : start -> stop -> step -> range = "range"
  
  let nums = range start stop step
  

  $ melc -ppx melppx output.ml
  File "output.ml", line 8, characters 17-22:
  8 | let nums = range start stop step
                       ^^^^^
  Error: Unbound value start
  Hint: Did you mean sqrt?
  [2]

Overloaded function

  $ cat > input.js <<\EOF
  > foo('hello');
  > foo(true);
  > EOF

  $ rebind input.js | tee output.ml
  type foo
  
  external foo : string -> foo = "foo";;
  
  foo Js.true_;;
  foo "hello"
  

  $ melc -ppx melppx output.ml
  File "output.ml", line 5, characters 4-12:
  5 | foo Js.true_;;
          ^^^^^^^^
  Error: Unbound value Js.true_
  [2]

Optional final argument(s)

  $ cat > input.js <<\EOF
  > const nums = range(start, stop, /* optional */ step);
  > EOF

  $ rebind input.js | tee output.ml
  type start
  type stop
  type step
  type range
  
  external range : start -> stop -> step -> range = "range"
  
  let nums = range start stop step
  

  $ melc -ppx melppx output.ml
  File "output.ml", line 8, characters 17-22:
  8 | let nums = range start stop step
                       ^^^^^
  Error: Unbound value start
  Hint: Did you mean sqrt?
  [2]

Options object argument

  $ cat > input.js <<\EOF
  > mkdir('src/main', /* optional */ {recursive: true});
  > EOF

  $ rebind input.js | tee output.ml
  type mkdirParam
  type mkdir
  
  external makeMkdirParam : recursive:unit -> unit -> mkdirParam = "" [@@mel.obj]
  external mkdir : string -> mkdirParam -> mkdir = "mkdir";;
  
  mkdir "src/main" [%mel.obj { recursive = Js.true_ }]
  

  $ melc -ppx melppx output.ml
  File "output.ml", line 7, characters 41-49:
  7 | mkdir "src/main" [%mel.obj { recursive = Js.true_ }]
                                               ^^^^^^^^
  Error: Unbound value Js.true_
  [2]

Model a callback

  $ cat > input.js <<\EOF
  > forEach(start, stop, item => console.log(item));
  > EOF

  $ rebind input.js | tee output.ml
  type start
  type stop
  type item
  type callback
  type forEach
  
  external forEach : start -> stop -> (item -> callback) -> forEach = "forEach";;
  
  forEach start stop (fun item -> console##log item)
  

  $ melc -ppx melppx output.ml
  File "output.ml", line 9, characters 8-13:
  9 | forEach start stop (fun item -> console##log item)
              ^^^^^
  Error: Unbound value start
  Hint: Did you mean sqrt?
  [2]

--- Objects ---

Create an object

  $ cat > input.js <<\EOF
  > const person = {id: 1, name: 'Bob'};
  > EOF

  $ rebind input.js | tee output.ml
  type person
  
  external makePerson : name:string -> id:float -> unit -> person = "" [@@mel.obj]
  
  let person = [%mel.obj { id = 1; name = "Bob" }]
  

  $ melc -ppx melppx output.ml
  // Generated by Melange
  'use strict';
  
  
  var person = {
    id: 1,
    name: "Bob"
  };
  
  exports.person = person;
  /* No side effect */

Get a prop

  $ cat > input.js <<\EOF
  > person.name;
  > EOF

  $ rebind input.js | tee output.ml
  type person
  type name
  
  external person : person = "person"
  external name : person -> name = "name" [@@mel.get];;
  
  person##name
  

  $ melc -ppx melppx output.ml
  File "output.ml", line 7, characters 0-12:
  7 | person##name
      ^^^^^^^^^^^^
  Error: This expression is not an object; it has type person
  [2]

Set a prop

  $ cat > input.js <<\EOF
  > person.id = 0;
  > EOF

  $ rebind input.js | tee output.ml
  person ## id #= 0
  

  $ melc -ppx melppx output.ml
  File "output.ml", line 1, characters 0-6:
  1 | person ## id #= 0
      ^^^^^^
  Error: Unbound value person
  [2]

Object with destructuring

  $ cat > input.js <<\EOF
  > const {id, name} = person;
  > EOF

  $ rebind input.js | tee output.ml
  let "destructuringNotImplemented" = person
  

  $ melc -ppx melppx output.ml
  File "output.ml", line 1, characters 36-42:
  1 | let "destructuringNotImplemented" = person
                                          ^^^^^^
  Error: Unbound value person
  [2]

--- Classes and OOP ---

Call a class constructor

  $ cat > input.js <<\EOF
  > const foo = new Foo();
  > EOF

  $ rebind input.js | tee output.ml
  type foo
  
  external foo : foo = "Foo" [@@mel.new]
  
  let foo = expressionPlaceholder
  

  $ melc -ppx melppx output.ml
  File "output.ml", line 5, characters 10-31:
  5 | let foo = expressionPlaceholder
                ^^^^^^^^^^^^^^^^^^^^^
  Error: Unbound value expressionPlaceholder
  [2]

Get an instance property

  $ cat > input.js <<\EOF
  > const bar = foo.bar;
  > EOF

  $ rebind input.js | tee output.ml
  type foo
  type bar
  
  external foo : foo = "foo"
  external bar : foo -> bar = "bar" [@@mel.get]
  
  let bar = foo##bar
  

  $ melc -ppx melppx output.ml
  File "output.ml", line 7, characters 10-18:
  7 | let bar = foo##bar
                ^^^^^^^^
  Error: This expression is not an object; it has type foo
  [2]

Set an instance property

  $ cat > input.js <<\EOF
  > foo.bar = 1;
  > EOF

  $ rebind input.js | tee output.ml
  foo ## bar #= 1
  

  $ melc -ppx melppx output.ml
  File "output.ml", line 1, characters 0-3:
  1 | foo ## bar #= 1
      ^^^
  Error: Unbound value foo
  [2]

Call a nullary instance method

  $ cat > input.js <<\EOF
  > foo.meth();
  > EOF

  $ rebind input.js | tee output.ml
  type foo
  type meth
  
  external meth : foo -> meth = "meth" [@@mel.send];;
  
  foo##meth ()
  

  $ melc -ppx melppx output.ml
  File "output.ml", line 6, characters 0-3:
  6 | foo##meth ()
      ^^^
  Error: Unbound value foo
  [2]

Non-mutating instance method

  $ cat > input.js <<\EOF
  > const newStr = str.replace(substr, newSubstr);
  > EOF

  $ rebind input.js | tee output.ml
  type substr
  type newSubstr
  type str
  type replace
  
  external replace : str -> substr -> newSubstr -> replace = "replace"
  [@@mel.send]
  
  let newStr = str##replace substr newSubstr
  

  $ melc -ppx melppx output.ml
  File "output.ml", line 9, characters 13-16:
  9 | let newStr = str##replace substr newSubstr
                   ^^^
  Error: Unbound value str
  [2]

Mutating instance method

  $ cat > input.js <<\EOF
  > arr.sort(compareFunction);
  > EOF

  $ rebind input.js | tee output.ml
  type compareFunction
  type arr
  type sort
  
  external sort : arr -> compareFunction -> sort = "sort" [@@mel.send];;
  
  arr##sort compareFunction
  

  $ melc -ppx melppx output.ml
  File "output.ml", line 7, characters 0-3:
  7 | arr##sort compareFunction
      ^^^
  Error: Unbound value arr
  Hint: Did you mean asr?
  [2]

--- Null and undefined ---

Check for undefined

  $ cat > input.js <<\EOF
  > foo.bar === undefined;
  > EOF

  $ rebind input.js | tee output.ml
  foo##bar == undefined
  

  $ melc -ppx melppx output.ml
  File "output.ml", line 1, characters 0-3:
  1 | foo##bar == undefined
      ^^^
  Error: Unbound value foo
  [2]

Check for null or undefined

  $ cat > input.js <<\EOF
  > foo.bar == null;
  > EOF

  $ rebind input.js | tee output.ml
  Js.Null_undefined.test foo##bar
  

  $ melc -ppx melppx output.ml
  File "output.ml", line 1, characters 0-22:
  1 | Js.Null_undefined.test foo##bar
      ^^^^^^^^^^^^^^^^^^^^^^
  Error: Unbound value Js.Null_undefined.test
  [2]

Single object

  $ cat > input.js <<\EOF
  > const languageMap = {
  >   Reason: "Reason",
  >   OCaml: "OCaml",
  > };
  > EOF

  $ rebind input.js | tee output.ml
  type languageMap
  
  external makeLanguageMap :
    _OCaml:string -> _Reason:string -> unit -> languageMap = ""
  [@@mel.obj]
  
  let languageMap = [%mel.obj { reason = "Reason"; oCaml = "OCaml" }]
  

  $ melc -ppx melppx output.ml
  // Generated by Melange
  'use strict';
  
  
  var languageMap = {
    reason: "Reason",
    oCaml: "OCaml"
  };
  
  exports.languageMap = languageMap;
  /* No side effect */

TODO - Appearances of `import` keyword

  $ cat > input.js <<\EOF
  > const worker = new Worker(new URL("./worker.js", import.meta.url), {
  >   type: "module",
  > });
  > EOF

  $ rebind input.js | tee output.ml
  type import
  type meta
  type url
  type uRL
  type uRLParam
  type worker
  
  external import : import = "import"
  external meta : import -> meta = "meta" [@@mel.get]
  external url : meta -> url = "url" [@@mel.get]
  external uRL : string -> url -> uRL = "URL" [@@mel.new]
  external makeURLParam : _type:string -> unit -> uRLParam = "" [@@mel.obj]
  external worker : uRL -> uRLParam -> worker = "Worker" [@@mel.new]
  
  let worker = expressionPlaceholder
  

  $ melc -ppx melppx output.ml
  File "output.ml", line 15, characters 13-34:
  15 | let worker = expressionPlaceholder
                    ^^^^^^^^^^^^^^^^^^^^^
  Error: Unbound value expressionPlaceholder
  [2]


TODO - React elements

import { Toaster } from './toaster';
 <Toaster />

TODO - React components

function OCamlLogo() {
return <span className="SquareLogo OCaml"></span>
}
let t = <OCamlLogo />

TODO - Bizarre character `/`

import * as Console from "./console";

Console(243)
