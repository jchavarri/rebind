Basic functions

  $ cat > input.js <<\EOF
  > const nano = Nano("test", 4);
  > EOF

  $ rebind input.js | tee output.ml
  type nano
  
  external nano : string -> float -> nano = "Nano"
  

  $ melc -ppx melppx output.ml
  // Generated by Melange
  /* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */

Require statements, more than one statement

  $ cat > input.js <<\EOF
  > const nano = require('nano')(5, "fsdf", 43);
  > const blue = require('blue')("gf");
  > EOF

  $ rebind input.js | tee output.ml
  type nano
  type blue
  
  external nano : float -> string -> float -> nano = "nano" [@@mel.module]
  external blue : string -> blue = "blue" [@@mel.module]
  

  $ melc -ppx melppx output.ml
  // Generated by Melange
  /* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */

Track identifiers across statements

  $ cat > input.js <<\EOF
  > const nano = require('nano');
  > const test = nano(5, "fsdf", 43);
  > EOF

  $ rebind input.js | tee output.ml
  type nano
  
  external nano : float -> string -> float -> nano = "nano" [@@mel.module]
  

  $ melc -ppx melppx output.ml
  // Generated by Melange
  /* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */

Single require

  $ cat > input.js <<\EOF
  > const blue = require('blue');
  > EOF

  $ rebind input.js | tee output.ml
  type blue
  

  $ melc -ppx melppx output.ml
  // Generated by Melange
  /* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */

Basic object property access

  $ cat > input.js <<\EOF
  > const nano = require('nano')('http://localhost:5984');
  > nano.db.test(23);
  > const blue = require('blue');
  > const go = blue.pill.jump(23);
  > EOF

  $ rebind input.js | tee output.ml
  type nano
  type db
  type test
  type blue
  type pill
  type jump
  
  external nano : string -> nano = "nano" [@@mel.module]
  external db : nano -> db = "db" [@@mel.get]
  external test : db -> float -> test = "test" [@@mel.send]
  external blue : blue = "blue" [@@mel.module]
  external pill : blue -> pill = "pill" [@@mel.get]
  external jump : pill -> float -> jump = "jump" [@@mel.send]
  

  $ melc -ppx melppx output.ml
  // Generated by Melange
  /* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */

Functions as callbacks

  $ cat > input.js <<\EOF
  > const nano = require('nano')('http://localhost:5984');
  > nano.db.create('foo', (err, body, headers) => { // ... stuff here
  > })
  > EOF

  $ rebind input.js | tee output.ml
  type nano
  type err
  type body
  type headers
  type callback
  type db
  type create
  
  external nano : string -> nano = "nano" [@@mel.module]
  external db : nano -> db = "db" [@@mel.get]
  
  external create : db -> string -> (err -> body -> headers -> callback) -> create
    = "create"
  [@@mel.send]
  

  $ melc -ppx melppx output.ml
  // Generated by Melange
  /* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */

Object constants

  $ cat > input.js <<\EOF
  > var Airtable = require('airtable');
  > Airtable.configure({
  >     endpointUrl: 'https://api.airtable.com',
  >     apiKey: 'YOUR_API_KEY'
  > });
  > EOF

  $ rebind input.js | tee output.ml
  type airtable2
  type configureParam
  type configure
  
  external makeConfigureParam :
    apiKey:string -> endpointUrl:string -> unit -> configureParam = ""
  [@@mel.obj]
  
  external airtable2 : airtable2 = "airtable" [@@mel.module]
  
  external configure : airtable2 -> configureParam -> configure = "configure"
  [@@mel.send]
  
  $ melc -ppx melppx output.ml
  // Generated by Melange
  /* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */

Objects, properties, callbacks, modules

  $ cat > input.js <<\EOF
  > var Airtable = require('airtable');
  > Airtable.configure({
  >     endpointUrl: 'https://api.airtable.com',
  >     apiKey: 'YOUR_API_KEY'
  > });
  > var base = Airtable.base('appXXXXXXXX');
  > base('MyBase').select({
  >   // Selecting the first 3 records in Grid view:
  >   maxRecords: 3,
  >   view: "Grid view"
  > }).eachPage(function page(records, fetchNextPage) {
  >   // This function (`page`) will get called for each page of records.
  > 
  >   records.forEach(function(record) {
  >       console.log('Retrieved', record.get('Task'));
  >   });
  > 
  >   // To fetch the next page of records, call `fetchNextPage`.
  >   // If there are more records, `page` will get called again.
  >   // If there are no more records, `done` will get called.
  >   fetchNextPage();
  > 
  > }, function done(err) {
  >   if (err) { console.error(err); return; }
  > });
  > EOF

  $ rebind input.js | tee output.ml
  type airtable2
  type configureParam
  type configure
  type base
  type records
  type fetchNextPage
  type page
  type err
  type done_
  type selectParam
  type select
  type eachPage
  
  external makeConfigureParam :
    apiKey:string -> endpointUrl:string -> unit -> configureParam = ""
  [@@mel.obj]
  
  external airtable2 : airtable2 = "airtable" [@@mel.module]
  
  external configure : airtable2 -> configureParam -> configure = "configure"
  [@@mel.send]
  
  external base : airtable2 -> string -> base = "base" [@@mel.send]
  
  external makeSelectParam :
    view:string -> maxRecords:float -> unit -> selectParam = ""
  [@@mel.obj]
  
  external select : base -> selectParam -> select = "select" [@@mel.send]
  
  external eachPage :
    select -> (records -> fetchNextPage -> page) -> (err -> done_) -> eachPage
    = "eachPage"
  [@@mel.send]
  

  $ melc -ppx melppx output.ml
  // Generated by Melange
  /* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */

Identifiers with same name

  $ cat > input.js <<\EOF
  > let jPush = JPush.jPush;
  > jPush.initPush();
  > EOF

  $ rebind input.js | tee output.ml
  type jPush
  type jPush2
  type initPush
  
  external jPush : jPush = "JPush"
  external jPush2 : jPush -> jPush2 = "jPush" [@@mel.get]
  external initPush : jPush2 -> initPush = "initPush" [@@mel.send]
  

  $ melc -ppx melppx output.ml
  // Generated by Melange
  /* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */

Stripe example

  $ cat > input.js <<\EOF
  > var stripe = require('stripe')('sk_test_...');
  > 
  > stripe.customers.create(
  >   { email: 'customer@example.com' },
  >   function(err, customer) {
  >     err; // null if no error occurred
  >     customer; // the created customer object
  >   }
  > );
  > EOF

  $ rebind input.js | tee output.ml
  type stripe
  type createParam
  type err
  type customer
  type callback
  type customers
  type create
  
  external stripe : string -> stripe = "stripe" [@@mel.module]
  external makeCreateParam : email:string -> unit -> createParam = "" [@@mel.obj]
  external customers : stripe -> customers = "customers" [@@mel.get]
  
  external create :
    customers -> createParam -> (err -> customer -> callback) -> create = "create"
  [@@mel.send]
  

  $ melc -ppx melppx output.ml
  // Generated by Melange
  /* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */

Case with `new`

  $ cat > input.js <<\EOF
  > // From https://github.com/jchavarri/rebind/issues/3
  > const client = new AWSAppSyncClient({
  >   url: graphqlEndpoint,
  >   region: region,
  >   auth: {
  >     type: authenticationType,
  >     apiKey: apiKey
  >   }
  > });
  > EOF

  $ rebind input.js | tee output.ml
  Fatal error: exception Failure("ocamlformat error")
  Raised at Stdlib.failwith in file "stdlib.ml", line 29, characters 17-33
  Called from Dune__exe__Rebind.processContent in file "src/native/rebind.re", line 52, characters 21-50
  Called from Dune__exe__Rebind in file "src/native/rebind.re", line 63, characters 9-36

  $ melc -ppx melppx output.ml
  // Generated by Melange
  /* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */

`new` from a module

  $ cat > input.js <<\EOF
  > const Blue = require('SomethingBlue');
  > const instance = new Blue("config");
  > EOF

  $ rebind input.js | tee output.ml
  type somethingBlue
  
  external somethingBlue : string -> somethingBlue = "SomethingBlue"
  [@@mel.new] [@@mel.module]
  

  $ melc -ppx melppx output.ml
  // Generated by Melange
  /* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */

Named import

  $ cat > input.js <<\EOF
  > import { Blue } from "SomethingBlue";
  > const instance = Blue("config");
  > EOF

  $ rebind input.js | tee output.ml
  type blue
  
  external blue : string -> blue = "Blue" [@@mel.module "SomethingBlue"]
  

  $ melc -ppx melppx output.ml
  // Generated by Melange
  /* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */

Default imports

  $ cat > input.js <<\EOF
  > // Example from https://reasonml.chat/t/how-to-improve-my-codes/663
  > import Keycloak from 'keycloak-js';
  > const keycloak = Keycloak('config/keycloak.json');
  > keycloak.init({ onLoad: 'login-required' }).success(function(authenticated) {
  >   alert(authenticated ? 'authenticated' : 'not authenticated');
  > }).error(function() {
  >   alert('failed to initialize');
  > });
  > EOF

  $ rebind input.js | tee output.ml
  type keycloak
  type callback
  type authenticated
  type initParam
  type init
  type success
  type error
  
  external keycloak : string -> keycloak = "default" [@@mel.module "keycloak-js"]
  external makeInitParam : onLoad:string -> unit -> initParam = "" [@@mel.obj]
  external init : keycloak -> initParam -> init = "init" [@@mel.send]
  
  external success : init -> (authenticated -> callback) -> success = "success"
  [@@mel.send]
  
  external error : success -> callback -> error = "error" [@@mel.send]
  

  $ melc -ppx melppx output.ml
  // Generated by Melange
  /* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */

Named imports with local name

  $ cat > input.js <<\EOF
  > import { Blue as Green } from "SomethingBlue";
  > const instance = Green("config");
  > const t = green(2);
  > EOF

  $ rebind input.js | tee output.ml
  type green
  type green2
  
  external green : string -> green = "Blue" [@@mel.module "SomethingBlue"]
  external green2 : float -> green2 = "green"
  

  $ melc -ppx melppx output.ml
  // Generated by Melange
  /* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */

Namespaced imports

  $ cat > input.js <<\EOF
  > import * as Blue from "SomethingBlue";
  > const instance = Blue("config");
  > EOF

  $ rebind input.js | tee output.ml
  type blue
  type somethingBlue
  
  external somethingBlue : string -> somethingBlue = "SomethingBlue"
  [@@mel.module]
  

  $ melc -ppx melppx output.ml
  // Generated by Melange
  /* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */

Unexpected token error (no need to run melc)

  $ cat > input.js <<\EOF
  > const t = Test({: 1, : 2});
  > EOF

  $ rebind input.js | tee output.ml
  Fatal error: exception Parse_error.Error(_)
  Raised at Parser_flow.do_parse in file "vendor/flow/parser_flow.ml", line 4550, characters 7-37
  Called from Shared.getBindings in file "src/shared/shared.re", line 36, characters 4-138
  Called from Dune__exe__Rebind.processContent in file "src/native/rebind.re", line 40, characters 34-73
  Called from Dune__exe__Rebind in file "src/native/rebind.re", line 63, characters 9-36

Using a reserved word (`then`)

  $ cat > input.js <<\EOF
  > var stripe = require("stripe");
  > stripe.createToken('bank_account').then(function(result) {});
  > EOF

  $ rebind input.js | tee output.ml
  type stripe
  type result
  type callback
  type createToken
  type then_
  
  external stripe : stripe = "stripe" [@@mel.module]
  
  external createToken : stripe -> string -> createToken = "createToken"
  [@@mel.send]
  
  external then_ : createToken -> (result -> callback) -> then_ = "then"
  [@@mel.send]
  

  $ melc -ppx melppx output.ml
  // Generated by Melange
  /* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */

Dots and other strange chars in import names

  $ cat > input.js <<\EOF
  > const BN = require('bn.js');
  > 
  > var a = new BN('dead', 16);
  > var b = new BN('101010', 2);
  > 
  > var res = a.add(b);
  > 
  > import * as stripe from 'stripe-js';
  > stripe.createToken('bank_account');
  > EOF

  $ rebind input.js | tee output.ml
  type bnjs
  type add
  type stripe
  type stripejs
  type createToken
  
  external bnjs : string -> float -> bnjs = "bn.js" [@@mel.new] [@@mel.module]
  external add : bnjs -> bnjs -> add = "add" [@@mel.send]
  external stripejs : stripejs = "stripe-js" [@@mel.module]
  
  external createToken : stripejs -> string -> createToken = "createToken"
  [@@mel.send]
  

  $ melc -ppx melppx output.ml
  // Generated by Melange
  /* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */

=== Examples from https://github.com/yawaramin/bucklescript-bindings-cookbook ===

--- Globals ---

Variable in global module

  $ cat > input.js <<\EOF
  > function calculateCircumference(radius) {
  >   return 2 * Math.PI * radius;
  > }
  > EOF

  $ rebind input.js | tee output.ml
  

  $ melc -ppx melppx output.ml
  // Generated by Melange
  /* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */

Function in global module

--- Modules ---

Function in commonJS/ES6 module

  $ cat > input.js <<\EOF
  > const path = require('path');
  > path.join('a', 'b')
  > EOF

  $ rebind input.js | tee output.ml
  type path
  type join
  
  external path : path = "path" [@@mel.module]
  external join : path -> string -> string -> join = "join" [@@mel.send]
  

  $ melc -ppx melppx output.ml
  // Generated by Melange
  /* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */

Import entire module as a value

  $ cat > input.js <<\EOF
  > const foo = require('foo');
  > foo(1);
  > EOF

  $ rebind input.js | tee output.ml
  type foo
  
  external foo : float -> foo = "foo" [@@mel.module]
  

  $ melc -ppx melppx output.ml
  // Generated by Melange
  /* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */

Import ES6 module default export

  $ cat > input.js <<\EOF
  > import foo from 'foo';
  > foo(1);
  > EOF

  $ rebind input.js | tee output.ml
  type foo
  
  external foo : float -> foo = "default" [@@mel.module "foo"]
  

  $ melc -ppx melppx output.ml
  // Generated by Melange
  /* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */

Function scoped inside an object in a module

  $ cat > input.js <<\EOF
  > const foo = require('foo');
  > foo.bar.baz();
  > EOF

  $ rebind input.js | tee output.ml
  type foo
  type bar
  type baz
  
  external foo : foo = "foo" [@@mel.module]
  external bar : foo -> bar = "bar" [@@mel.get]
  external baz : bar -> baz = "baz" [@@mel.send]
  

  $ melc -ppx melppx output.ml
  // Generated by Melange
  /* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */

Function with rest args

  $ cat > input.js <<\EOF
  > const dir = path.join('a', 'b', 'c')
  > EOF

  $ rebind input.js | tee output.ml
  type path
  type join
  
  external join : path -> string -> string -> string -> join = "join" [@@mel.send]
  

  $ melc -ppx melppx output.ml
  // Generated by Melange
  /* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */

Call a function with named arguments for readability

  $ cat > input.js <<\EOF
  > const nums = range(start, stop, step)
  > EOF

  $ rebind input.js | tee output.ml
  type start
  type stop
  type step
  type range
  
  external range : start -> stop -> step -> range = "range"
  

  $ melc -ppx melppx output.ml
  // Generated by Melange
  /* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */

Overloaded function

  $ cat > input.js <<\EOF
  > foo('hello');
  > foo(true);
  > EOF

  $ rebind input.js | tee output.ml
  type foo
  
  external foo : string -> foo = "foo"
  

  $ melc -ppx melppx output.ml
  // Generated by Melange
  /* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */

Optional final argument(s)

  $ cat > input.js <<\EOF
  > const nums = range(start, stop, /* optional */ step);
  > EOF

  $ rebind input.js | tee output.ml
  type start
  type stop
  type step
  type range
  
  external range : start -> stop -> step -> range = "range"
  

  $ melc -ppx melppx output.ml
  // Generated by Melange
  /* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */

Options object argument

  $ cat > input.js <<\EOF
  > mkdir('src/main', /* optional */ {recursive: true});
  > EOF

  $ rebind input.js | tee output.ml
  type mkdirParam
  type mkdir
  
  external makeMkdirParam : recursive:unit -> unit -> mkdirParam = "" [@@mel.obj]
  external mkdir : string -> mkdirParam -> mkdir = "mkdir"
  

  $ melc -ppx melppx output.ml
  // Generated by Melange
  /* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */

Model a callback

  $ cat > input.js <<\EOF
  > forEach(start, stop, item => console.log(item));
  > EOF

  $ rebind input.js | tee output.ml
  type start
  type stop
  type item
  type callback
  type forEach
  
  external forEach : start -> stop -> (item -> callback) -> forEach = "forEach"
  

  $ melc -ppx melppx output.ml
  // Generated by Melange
  /* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */

--- Objects ---

Create an object

  $ cat > input.js <<\EOF
  > const person = {id: 1, name: 'Bob'};
  > EOF

  $ rebind input.js | tee output.ml
  Fatal error: exception Failure("ocamlformat error")
  Raised at Stdlib.failwith in file "stdlib.ml", line 29, characters 17-33
  Called from Dune__exe__Rebind.processContent in file "src/native/rebind.re", line 52, characters 21-50
  Called from Dune__exe__Rebind in file "src/native/rebind.re", line 63, characters 9-36

  $ melc -ppx melppx output.ml
  // Generated by Melange
  /* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */

Get a prop

  $ cat > input.js <<\EOF
  > person.name;
  > EOF

  $ rebind input.js | tee output.ml
  type person
  type name
  
  external person : person = "person"
  external name : person -> name = "name" [@@mel.get]
  

  $ melc -ppx melppx output.ml
  // Generated by Melange
  /* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */

Set a prop

  $ cat > input.js <<\EOF
  > person.id = 0;
  > EOF

  $ rebind input.js | tee output.ml
  

  $ melc -ppx melppx output.ml
  // Generated by Melange
  /* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */

Object with destructuring

  $ cat > input.js <<\EOF
  > const {id, name} = person;
  > EOF

  $ rebind input.js | tee output.ml
  

  $ melc -ppx melppx output.ml
  // Generated by Melange
  /* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */

--- Classes and OOP ---

Call a class constructor

  $ cat > input.js <<\EOF
  > const foo = new Foo();
  > EOF

  $ rebind input.js | tee output.ml
  type foo
  
  external foo : foo = "Foo" [@@mel.new]
  

  $ melc -ppx melppx output.ml
  // Generated by Melange
  /* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */

Get an instance property

  $ cat > input.js <<\EOF
  > const bar = foo.bar;
  > EOF

  $ rebind input.js | tee output.ml
  type foo
  type bar
  
  external foo : foo = "foo"
  external bar : foo -> bar = "bar" [@@mel.get]
  

  $ melc -ppx melppx output.ml
  // Generated by Melange
  /* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */

Set an instance property

  $ cat > input.js <<\EOF
  > foo.bar = 1;
  > EOF

  $ rebind input.js | tee output.ml
  

  $ melc -ppx melppx output.ml
  // Generated by Melange
  /* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */

Call a nullary instance method

  $ cat > input.js <<\EOF
  > foo.meth();
  > EOF

  $ rebind input.js | tee output.ml
  type foo
  type meth
  
  external meth : foo -> meth = "meth" [@@mel.send]
  

  $ melc -ppx melppx output.ml
  // Generated by Melange
  /* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */

Non-mutating instance method

  $ cat > input.js <<\EOF
  > const newStr = str.replace(substr, newSubstr);
  > EOF

  $ rebind input.js | tee output.ml
  type substr
  type newSubstr
  type str
  type replace
  
  external replace : str -> substr -> newSubstr -> replace = "replace"
  [@@mel.send]
  

  $ melc -ppx melppx output.ml
  // Generated by Melange
  /* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */

Mutating instance method

  $ cat > input.js <<\EOF
  > arr.sort(compareFunction);
  > EOF

  $ rebind input.js | tee output.ml
  type compareFunction
  type arr
  type sort
  
  external sort : arr -> compareFunction -> sort = "sort" [@@mel.send]
  

  $ melc -ppx melppx output.ml
  // Generated by Melange
  /* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */

--- Null and undefined ---

Check for undefined

  $ cat > input.js <<\EOF
  > foo.bar === undefined;
  > EOF

  $ rebind input.js | tee output.ml
  

  $ melc -ppx melppx output.ml
  // Generated by Melange
  /* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */

Check for null or undefined

  $ cat > input.js <<\EOF
  > foo.bar == null;
  > EOF

  $ rebind input.js | tee output.ml
  

  $ melc -ppx melppx output.ml
  // Generated by Melange
  /* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
